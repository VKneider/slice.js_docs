<h1 id="routing">Routing in Slice.js</h1>
<p>
  Slice.js provides a powerful and flexible routing system that allows you to create single-page applications
  with multiple views. The routing system is built on top of the browser's History API and offers both
  declarative and programmatic ways to define and navigate between routes.
</p>

<h2 id="router-setup">Router Setup</h2>
<p>
  Slice.js routing starts with defining your routes in a configuration file. By default, Slice.js looks for
  this configuration in <code>src/routes.js</code>, but you can customize the path in <code>sliceConfig.json</code>.
</p>

<div class="routes-config-example"></div>

<p>
  The route configuration consists of an array of route objects, each with at least a <code>path</code> and a 
  <code>component</code> property. The router uses this configuration to match URL paths to components.
</p>

<div class="routing-visualization"></div>

<h2 id="route-component">Using the Route Component</h2>
<p>
  The <code>slice-route</code> component is the simplest way to define a route in your components. It renders the specified
  component when the current URL matches the defined path.
</p>

<div class="route-component-example"></div>

<p>
  When defining a route component, you need to specify:
</p>
<ul>
  <li><strong>path</strong>: The URL path that triggers this route</li>
  <li><strong>component</strong>: The name of the component to render when the path matches</li>
</ul>

<h2 id="multi-route-component">Using the MultiRoute Component</h2>
<p>
  The <code>slice-multi-route</code> component allows you to define multiple routes in a single component. This
  is particularly useful for sections of your application that have multiple related views, like dashboards or
  content management systems.
</p>

<div class="multi-route-example"></div>

<p>
  The MultiRoute component takes an array of route objects through its <code>routes</code> property. Each route
  object has the same structure as in the main routes configuration.
</p>

<h2 id="dynamic-routes">Dynamic Routes with Parameters</h2>
<p>
  Slice.js supports dynamic routes with URL parameters. You can define parameters in your route paths using the
  <code>${paramName}</code> syntax. These parameters are then passed to your component through the <code>props.params</code> object.
</p>

<div class="dynamic-routes-example"></div>

<p>
  When a dynamic route matches, the parameters are extracted from the URL and made available to your component.
  This allows you to create reusable components that can display different content based on the URL parameters.
</p>

<h2 id="programmatic-navigation">Programmatic Navigation</h2>
<p>
  In addition to declarative routing with components, Slice.js provides a programmatic way to navigate between
  routes using the <code>slice.router.navigate()</code> method.
</p>

<div class="programmatic-nav-example"></div>



<h2 id="nested-routes">Nested Routes and Layouts</h2>
<p>
  Slice.js supports nested routes, which are powerful for creating complex UIs with shared layouts. You can
  define child routes in the route configuration, and they will inherit the parent route's path as a prefix.
</p>

<div class="nested-routes-example"></div>

<p>
  In this example, the AdminLayout component acts as a container for all administrative pages, providing a
  consistent layout while the content area changes based on the current route.
</p>

<h2 id="route-lifecycle">Route Lifecycle and Events</h2>
<p>
  When a route changes, Slice.js router triggers several events:
</p>
<ol>
  <li>The previous component is removed from the DOM</li>
  <li>The new component is built and inserted into the DOM</li>
  <li>If the new component has an <code>init</code> method, it's called</li>
  <li>If switching between routes that use the same component, the <code>update</code> method is called instead</li>
</ol>

<h2 id="route-best-practices">Best Practices for Routing</h2>
<ul>
  <li>Organize your routes logically, grouping related routes together with nested routes</li>
  <li>Use the most specific component for your routing needs - Route for single routes, MultiRoute for related groups</li>
  <li>Keep route parameters simple and descriptive</li>
  <li>Add a catch-all 404 route to handle unmatched paths</li>
  <li>Consider adding loading indicators during navigation, especially for routes that fetch data</li>
  <li>Use the programmatic navigation API for complex navigation scenarios like redirects or conditional navigation</li>
</ul>